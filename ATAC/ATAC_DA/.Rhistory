for (i in 1:length(comparisons)) {
edgeRObject<- get(comparisons[i])
df[,i] <- edgeRObject$table[[statistic]]
}
colnames(df) <- names(DEi)
rownames(df) <- rownames(edgeRObject)
df           <- data.frame(df)
return(df)
}
# Create an object of the logFC for each comparison
m <- createExpResultsDF("logFC")
# Create an object of the pvals for each gene in each expiriment
pvals <- createExpResultsDF("PValue")
# Adjust the pval object to fdr for a padj object
p.adj <- apply(pvals, 2, p.adjust, method="BH")
# Create an object of logCPM for each gene in each expiriment
logCPM <- Pax_0hpaVSPax_24hpa$table$logCPM
logCPM <- data.frame(logCPM)
# Add researcher readable column names so that they can be combined for final output
colnames(pvals) <- paste("pval", colnames(pvals), sep=".")
colnames(p.adj) <- paste("padj", colnames(m), sep=".")
colnames(m)     <- paste("fc", colnames(m), sep=".")
# add an object that will be designated flag, if up-regulated = 1, down = -1 and not DE = 0
flags <- matrix("NO", ncol=length(DEi), nrow=nrow(m))
for (i in 1:length(DEi)) {
flags[DEi[[i]]$dn, i] <- "DOWN"
flags[DEi[[i]]$up, i] <- "UP"
}
colnames(flags) <- paste0("DE.", names(DEi))
rownames(flags) <- rownames(m)
# Create a summary dataframe of all metrics combined
final.table <- data.frame(m, logCPM, flags, pvals, p.adj)
# Add Gene annotation
genes.gr <- readRDS("Xtrop9.gr")
TSS <- promoters(genes.gr, upstream=0, downstream = 1)
DistanceToTSS <- function(peaks.gr, TSS.gr) {
## Run DistanceToNearest (GRanges fn) to get distances from TSS for all peaks
TSS.distance <- data.frame(distanceToNearest(peaks.gr, TSS.gr, ignore.strand=TRUE))
colnames(TSS.distance) <- c("Peaks", "Genes", "Distance")
## A really long way to figure out which peaks are upstream/downstream from TSS
positive.downstream <- which((start(peaks.gr[TSS.distance$Peaks]) > start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "+") == TRUE)
positive.upstream   <- which((end(peaks.gr[TSS.distance$Peaks]) < start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "+") == TRUE)
negative.upstream   <- which((start(peaks.gr[TSS.distance$Peaks]) > start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "-") == TRUE)
negative.downstream <- which((end(peaks.gr[TSS.distance$Peaks]) < start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "-") == TRUE)
## Change TSS.distance to integer value not absolute (both + and - distance from TSS)
TSS.distance$Distance[positive.upstream] <- TSS.distance$Distance[positive.upstream] * -1
TSS.distance$Distance[positive.downstream] <- TSS.distance$Distance[positive.downstream]
TSS.distance$Distance[negative.upstream] <- TSS.distance$Distance[negative.upstream] * -1
TSS.distance$Distance[negative.downstream] <- TSS.distance$Distance[negative.downstream]
## Add a column to the GRanges to add the nearest GENE and DistanceToTSS of said gene
peaks.gr$Gene <- NA
peaks.gr$Gene[TSS.distance$Peaks] <- names(TSS.gr)[TSS.distance$Genes]
peaks.gr$DistanceToTSS <- NA
peaks.gr$DistanceToTSS[TSS.distance$Peaks] <- TSS.distance$Distance
return(peaks.gr)
}
# add where ATAC Peak coordinates fall
loadSummits <- function(file) {
##  Read in table and assign it to the global environment
temp.table <- read.table(file, sep="\t", header=FALSE)
colnames(temp.table) <- c("Chrom", "Start", "Stop", "Peak", "Pileup")
temp.table$Strand <- "*"
temp.table <- temp.table[which(temp.table$Start > 200),]
temp.gr <- with(temp.table, GRanges(Chrom, IRanges(Start, Stop), Strand, Peak, Pileup))
temp.gr <- resize(temp.gr, 400, fix="center")
names(temp.gr) <- temp.gr$Peak
temp.gr <- DistanceToTSS(temp.gr, TSS)
return(temp.gr)
}
# Load bed file with all peaks and coordinates
ALL_merged_summits.gr <- loadSummits(file="ALL_merged_summits.bed")
head(ALL_merged_summits.gr)
# Function to add columns from granges to final table
addColumns <- function(anno.gr, table) {
## Add Columngs from GRanges to finalOutTable
names(anno.gr) <- gsub("All", "ALL", names(anno.gr))
remote.All  <- match(rownames(table), names(anno.gr))
table$Chrom <- as.character(seqnames(anno.gr)[remote.All])
table$Start <- start(anno.gr[remote.All])
table$End   <- end(anno.gr[remote.All])
table$Peak  <- anno.gr$Peak[remote.All]
table$Gene  <- anno.gr$Gene[remote.All]
table$DistanceToTSS  <- anno.gr$DistanceToTSS[remote.All]
return(table)
}
# Make final table
final.table.timepoints<- addColumns(ALL_merged_summits.gr, final.table)
# view final DA table
datatable(final.table.timepoints, caption = "DA Timepoints within Condition")
# Save Table out
write.table(final.table.timepoints,
file="outs/DA_timepoints.txt",
sep="\t",
quote=F,
col.names=NA)
Group <- factor(paste(targets$CellID, targets$TimePt, sep="_")) #sample as factors cince no replicates]
y <- DGEList(countData, group=Group) #create object with counts from countData and experimental conditions from Group
### Normalizing
y <- calcNormFactors(y) #calculate normalization factors to scale DGEList
n.counts <-cpm(y, normalized.lib.sizes=TRUE, log=TRUE)
log.counts <- n.counts
design <- model.matrix(~0+Group, data=y$samples) #makes design matrix
colnames(design) <- levels(Group)
# save out log.counts for heatmap
write.table(log.counts,
file="outs/paxVall_log.counts.txt",
sep="\t",
quote=F,
col.names=NA)
# Running edgeR stat/Dispersion function
y <- estimateGLMCommonDisp(y, design) #does something to DGE datasets
y <- estimateGLMTrendedDisp(y, design) #does something to DGE datasets
y <- estimateGLMTagwiseDisp(y, design) #does something to DGE datasets
fit <- glmFit(y, design)
# make contrasts
# Makes matrix of all possible contrasts
design.pairs <- function(levels) {
n <- length(levels)
design <- matrix(0,n,choose(n,2))
rownames(design) <- levels
colnames(design) <- 1:choose(n,2)
k <- 0
for (i in 1:(n-1))
for (j in (i+1):n) {
k <- k+1
design[i,k] <- 1
design[j,k] <- -1
colnames(design)[k] <- paste(levels[i],"-",levels[j],sep="")
}
design
}
# Making contrast
my.contrasts <- design.pairs(colnames(design)) #make contrast matrix
# select contrasts
my.contrasts <- makeContrasts(PaxVSWhole_6hpa=Pax_6hpa-All_Tissue_6hpa,
PaxVSWhole_24hpa=Pax_24hpa-All_Tissue_24hpa,
PaxVSWhole_72hpa=Pax_72hpa-All_Tissue_72hpa,
PaxVSWhole_0hpa=Pax_0hpa-All_Tissue_0hpa,
PaxVSWhole_WT=Pax_uninjured-All_Tissue_uninjured,
levels=design)
# Run the likelihood ratio test on all contrasts
runContrastsLRT <- function(x) {
comparisons <- colnames(my.contrasts)
outComp     <- gsub("-", "VS", comparisons)
for (i in 1:length(comparisons)) {
tmp.glm <- glmLRT(fit, contrast=my.contrasts[,comparisons[i]])
assign(outComp[i], tmp.glm, envir = .GlobalEnv)
}
}
runContrastsLRT(my.contrasts)
# Function that pulls DE express
#p threshold=pc
sumStats <- function(x,fc=1,pc=0.01){
up <- x$table$logFC > 0
dn <- x$table$logFC < 0
## indexes of genes with padj < 0.05
padj <- p.adjust(x$table$PValue, method="BH") < pc
## indexes of genes with pvals < 0.05
pval <- x$table$PValue < pc
## indexes of genes with pval of 0.05 and FC of greator than 1 or -1
ng.up <- x$table$logFC > fc & pval
ng.dn <- x$table$logFC < -1*fc & pval
## print out a summary table
headers <- c("padj", "pval","up","dn")
values <- c(sum(padj),
sum(pval),
sum(ng.up),
sum(ng.dn))
names(values) <- headers
## return a list of indexes for the genes that are DE by pval and padj
print(values)
return(list(up=which(pval & up),
dn=which(pval & dn),
upfc=which(ng.up),
dnfc=which(ng.dn),
upq=which(padj & up),
dnq=which(padj & dn),
padj=which(padj),
summary=values))
}
runsumStats <- function() {
comparisons <- ls(pattern = "VS", envir = .GlobalEnv)
GOcomp <- -1*grep(pattern = "GO", comparisons)
if (length(GOcomp) > 0) {
comparisons <- comparisons[GOcomp]
}
listD <- list()
for (i in 1:length(comparisons)) {
print(comparisons[i])
comp <- comparisons[i]
listD[[comp]] <- sumStats(get(comparisons[i]), pc=0.01)
}
return(listD)
}
# Create an object with the indexes of gﬁenes that are DE for each experiment
DEi <- runsumStats()
# Function to make results
createExpResultsDF <- function(statistic) {
comparisons <- ls(pattern = "VS", envir = .GlobalEnv)
GOcomp <- -1*grep(pattern = "GO", comparisons)
if (length(GOcomp) > 0) {
comparisons <- comparisons[GOcomp]
}
df <- matrix(ncol = length(comparisons), nrow = nrow(get(comparisons[1])$table))
for (i in 1:length(comparisons)) {
edgeRObject<- get(comparisons[i])
df[,i] <- edgeRObject$table[[statistic]]
}
colnames(df) <- names(DEi)
rownames(df) <- rownames(edgeRObject)
df           <- data.frame(df)
return(df)
}
### Create an object of the logFC for each comparison
m <- createExpResultsDF("logFC")
### Create an object of the pvals for each gene in each expiriment
pvals <- createExpResultsDF("PValue")
### Adjust the pval object to fdr for a padj object
p.adj <- apply(pvals, 2, p.adjust, method="BH")
### Create an object of logCPM for each gene in each expiriment
logCPM <- PaxVSWhole_WT$table$logCPM
logCPM <- data.frame(logCPM)
# Add researcher readable column names so that they can be combined for final output
colnames(pvals) <- paste("pval", colnames(pvals), sep=".")
colnames(p.adj) <- paste("padj", colnames(m), sep=".")
colnames(m)     <- paste("fc", colnames(m), sep=".")
# add an object that will be designated flag, if up-regulated = 1, down = -1 and not DE = 0
flags <- matrix("NO", ncol=length(DEi), nrow=nrow(m))
for (i in 1:length(DEi)) {
flags[DEi[[i]]$dn, i] <- "DOWN"
flags[DEi[[i]]$up, i] <- "UP"
}
colnames(flags) <- paste0("DE.", names(DEi))
rownames(flags) <- rownames(m)
# Create a summary dataframe of all metrics combined
final.table <- data.frame(m, logCPM, flags, pvals, p.adj)
# Add Gene annotation
genes.gr <- readRDS("Xtrop9.gr")
TSS <- promoters(genes.gr, upstream=0, downstream = 1)
DistanceToTSS <- function(peaks.gr, TSS.gr) {
## Run DistanceToNearest (GRanges fn) to get distances from TSS for all peaks
TSS.distance <- data.frame(distanceToNearest(peaks.gr, TSS.gr, ignore.strand=TRUE))
colnames(TSS.distance) <- c("Peaks", "Genes", "Distance")
## A really long way to figure out which peaks are upstream/downstream from TSS
positive.downstream <- which((start(peaks.gr[TSS.distance$Peaks]) > start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "+") == TRUE)
positive.upstream   <- which((end(peaks.gr[TSS.distance$Peaks]) < start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "+") == TRUE)
negative.upstream   <- which((start(peaks.gr[TSS.distance$Peaks]) > start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "-") == TRUE)
negative.downstream <- which((end(peaks.gr[TSS.distance$Peaks]) < start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "-") == TRUE)
## Change TSS.distance to integer value not absolute (both + and - distance from TSS)
TSS.distance$Distance[positive.upstream] <- TSS.distance$Distance[positive.upstream] * -1
TSS.distance$Distance[positive.downstream] <- TSS.distance$Distance[positive.downstream]
TSS.distance$Distance[negative.upstream] <- TSS.distance$Distance[negative.upstream] * -1
TSS.distance$Distance[negative.downstream] <- TSS.distance$Distance[negative.downstream]
## Add a column to the GRanges to add the nearest GENE and DistanceToTSS of said gene
peaks.gr$Gene <- NA
peaks.gr$Gene[TSS.distance$Peaks] <- names(TSS.gr)[TSS.distance$Genes]
peaks.gr$DistanceToTSS <- NA
peaks.gr$DistanceToTSS[TSS.distance$Peaks] <- TSS.distance$Distance
return(peaks.gr)
}
# add where ATAC Peak coordinates fall
loadSummits <- function(file) {
##  Read in table and assign it to the global environment
temp.table <- read.table(file, sep="\t", header=FALSE)
colnames(temp.table) <- c("Chrom", "Start", "Stop", "Peak", "Pileup")
temp.table$Strand <- "*"
temp.table <- temp.table[which(temp.table$Start > 200),]
temp.gr <- with(temp.table, GRanges(Chrom, IRanges(Start, Stop), Strand, Peak, Pileup))
temp.gr <- resize(temp.gr, 400, fix="center")
names(temp.gr) <- temp.gr$Peak
temp.gr <- DistanceToTSS(temp.gr, TSS)
return(temp.gr)
}
# Load bed file with all peaks and coordinates
ALL_merged_summits.gr <- loadSummits(file="ALL_merged_summits.bed")
head(ALL_merged_summits.gr)
# Function to add columns from granges to final table
addColumns <- function(anno.gr, table) {
## Add Columngs from GRanges to finalOutTable
names(anno.gr) <- gsub("All", "ALL", names(anno.gr))
remote.All  <- match(rownames(table), names(anno.gr))
table$Chrom <- as.character(seqnames(anno.gr)[remote.All])
table$Start <- start(anno.gr[remote.All])
table$End   <- end(anno.gr[remote.All])
table$Peak  <- anno.gr$Peak[remote.All]
table$Gene  <- anno.gr$Gene[remote.All]
table$DistanceToTSS  <- anno.gr$DistanceToTSS[remote.All]
return(table)
}
# Make final table
final.table.paxVall<- addColumns(ALL_merged_summits.gr, final.table)
# view final DA table
datatable(final.table.paxVall, caption = "DA Timepoints between Condition")
# Save Table out
write.table(final.table.timepoints,
file="outs/DA_paxVall.txt",
sep="\t",
quote=F,
col.names=NA)
# Read in if not continuing from before
targets <- read.table("targets.txt", sep = "\t")
countData <- read.table("countData.txt", sep = "\t")
# Read in if not continuing from before
targets <- read.table("outs/targets.txt", sep = "\t")
countData <- read.table("outs/countData.txt", sep = "\t")
Group <- factor(targets$CellID) #sample as factors cince no replicates]
y <- DGEList(countData, group=Group) #create object with counts from countData and experimental conditions from Group
### Normalizing
y <- calcNormFactors(y) #calculate normalization factors to scale DGEList
n.counts <-cpm(y, normalized.lib.sizes=TRUE, log=TRUE)
log.counts <- n.counts
design <- model.matrix(~0+Group, data=y$samples) #makes design matrix
colnames(design) <- levels(Group)
write.table(log.counts,
file="outs/log.counts_paxVall_aggregate.txt",
sep="\t",
quote=F,
col.names=NA)
# Running edgeR stat/Dispersion function
y <- estimateGLMCommonDisp(y, design) #does something to DGE datasets
y <- estimateGLMTrendedDisp(y, design) #does something to DGE datasets
y <- estimateGLMTagwiseDisp(y, design) #does something to DGE datasets
fit <- glmFit(y, design)
my.contrasts <- makeContrasts(PaxVSWholeALL=Pax-All_Tissue,
levels=design)
# Run the likelihood ratio test on all contrasts
# Run the likelihood ratio test on all contrasts
runContrastsLRT <- function(x) {
comparisons <- colnames(my.contrasts)
outComp     <- gsub("-", "VS", comparisons)
for (i in 1:length(comparisons)) {
tmp.glm <- glmLRT(fit, contrast=my.contrasts[,comparisons[i]])
assign(outComp[i], tmp.glm, envir = .GlobalEnv)
}
}
runContrastsLRT(my.contrasts)
### Function that pulls DE express
#p threshold=pc
sumStats <- function(x,fc=1,pc=0.01){
up <- x$table$logFC > 0
dn <- x$table$logFC < 0
## indexes of genes with padj < 0.05
padj <- p.adjust(x$table$PValue, method="BH") < pc
## indexes of genes with pvals < 0.05
pval <- x$table$PValue < pc
## indexes of genes with pval of 0.05 and FC of greator than 1 or -1
ng.up <- x$table$logFC > fc & pval
ng.dn <- x$table$logFC < -1*fc & pval
## print out a summary table
headers <- c("padj", "pval","up","dn")
values <- c(sum(padj),
sum(pval),
sum(ng.up),
sum(ng.dn))
names(values) <- headers
## return a list of indexes for the genes that are DE by pval and padj
print(values)
return(list(up=which(pval & up),
dn=which(pval & dn),
upfc=which(ng.up),
dnfc=which(ng.dn),
upq=which(padj & up),
dnq=which(padj & dn),
padj=which(padj),
summary=values))
}
runsumStats <- function() {
comparisons <- ls(pattern = "VS", envir = .GlobalEnv)
GOcomp <- -1*grep(pattern = "GO", comparisons)
if (length(GOcomp) > 0) {
comparisons <- comparisons[GOcomp]
}
listD <- list()
for (i in 1:length(comparisons)) {
print(comparisons[i])
comp <- comparisons[i]
listD[[comp]] <- sumStats(get(comparisons[i]), pc=0.01)
}
return(listD)
}
### Create an object with the indexes of gﬁenes that are DE for each experiment
DEi <- runsumStats()
# Function to make results
createExpResultsDF <- function(statistic) {
comparisons <- ls(pattern = "VS", envir = .GlobalEnv)
GOcomp <- -1*grep(pattern = "GO", comparisons)
if (length(GOcomp) > 0) {
comparisons <- comparisons[GOcomp]
}
df <- matrix(ncol = length(comparisons), nrow = nrow(get(comparisons[1])$table))
for (i in 1:length(comparisons)) {
edgeRObject<- get(comparisons[i])
df[,i] <- edgeRObject$table[[statistic]]
}
colnames(df) <- names(DEi)
rownames(df) <- rownames(edgeRObject)
df           <- data.frame(df)
return(df)
}
### Create an object of the logFC for each comparison
m <- createExpResultsDF("logFC")
### Create an object of the pvals for each gene in each expiriment
pvals <- createExpResultsDF("PValue")
### Adjust the pval object to fdr for a padj object
p.adj <- apply(pvals, 2, p.adjust, method="BH")
### Create an object of logCPM for each gene in each expiriment
logCPM <- PaxVSWholeALL$table$logCPM
logCPM <- data.frame(logCPM)
# Add researcher readable column names so that they can be combined for final output
colnames(pvals) <- paste("pval", colnames(pvals), sep=".")
colnames(p.adj) <- paste("padj", colnames(m), sep=".")
colnames(m)     <- paste("fc", colnames(m), sep=".")
### add an object that will be designated flag, if up-regulated = 1, down = -1 and not DE = 0
flags <- matrix("NO", ncol=length(DEi), nrow=nrow(m))
for (i in 1:length(DEi)) {
flags[DEi[[i]]$dn, i] <- "DOWN"
flags[DEi[[i]]$up, i] <- "UP"
}
colnames(flags) <- paste0("DE.p.", names(DEi))
rownames(flags) <- rownames(m)
### add an object that will be designated flag, if up-regulated = 1, down = -1 and not DE = 0
flags.fc <- matrix("NO", ncol=length(DEi), nrow=nrow(m))
for (i in 1:length(DEi)) {
flags.fc[DEi[[i]]$dnfc, i] <- "DOWN"
flags.fc[DEi[[i]]$upfc, i] <- "UP"
}
colnames(flags.fc) <- paste0("DE.p.fc", names(DEi))
rownames(flags.fc) <- rownames(m)
### add an object that will be designated flag, if up-regulated = 1, down = -1 and not DE = 0
flags.q <- matrix("NO", ncol=length(DEi), nrow=nrow(m))
for (i in 1:length(DEi)) {
flags.q[DEi[[i]]$dnq, i] <- "DOWN"
flags.q[DEi[[i]]$upq, i] <- "UP"
}
colnames(flags.q) <- paste0("DE.q", names(DEi))
rownames(flags.q) <- rownames(m)
### Create a summary dataframe of all metrics combined
final.table <- data.frame(m, logCPM, flags, flags.q, flags.fc, pvals, p.adj)
### Add Gene annotation
genes.gr <- readRDS("Xtrop9.gr")
TSS <- promoters(genes.gr, upstream=0, downstream = 1)
DistanceToTSS <- function(peaks.gr, TSS.gr) {
## Run DistanceToNearest (GRanges fn) to get distances from TSS for all peaks
TSS.distance <- data.frame(distanceToNearest(peaks.gr, TSS.gr, ignore.strand=TRUE))
colnames(TSS.distance) <- c("Peaks", "Genes", "Distance")
## A really long way to figure out which peaks are upstream/downstream from TSS
positive.downstream <- which((start(peaks.gr[TSS.distance$Peaks]) > start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "+") == TRUE)
positive.upstream   <- which((end(peaks.gr[TSS.distance$Peaks]) < start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "+") == TRUE)
negative.upstream   <- which((start(peaks.gr[TSS.distance$Peaks]) > start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "-") == TRUE)
negative.downstream <- which((end(peaks.gr[TSS.distance$Peaks]) < start(TSS.gr[TSS.distance$Genes]) & strand(TSS.gr[TSS.distance$Genes]) == "-") == TRUE)
## Change TSS.distance to integer value not absolute (both + and - distance from TSS)
TSS.distance$Distance[positive.upstream] <- TSS.distance$Distance[positive.upstream] * -1
TSS.distance$Distance[positive.downstream] <- TSS.distance$Distance[positive.downstream]
TSS.distance$Distance[negative.upstream] <- TSS.distance$Distance[negative.upstream] * -1
TSS.distance$Distance[negative.downstream] <- TSS.distance$Distance[negative.downstream]
## Add a column to the GRanges to add the nearest GENE and DistanceToTSS of said gene
peaks.gr$Gene <- NA
peaks.gr$Gene[TSS.distance$Peaks] <- names(TSS.gr)[TSS.distance$Genes]
peaks.gr$DistanceToTSS <- NA
peaks.gr$DistanceToTSS[TSS.distance$Peaks] <- TSS.distance$Distance
return(peaks.gr)
}
### Where the add where ATAC Peak coordinates fall
loadSummits <- function(file) {
##  Read in table and assign it to the global environment
temp.table <- read.table(file, sep="\t", header=FALSE)
colnames(temp.table) <- c("Chrom", "Start", "Stop", "Peak", "Pileup")
temp.table$Strand <- "*"
temp.table <- temp.table[which(temp.table$Start > 200),]
temp.gr <- with(temp.table, GRanges(Chrom, IRanges(Start, Stop), Strand, Peak, Pileup))
temp.gr <- resize(temp.gr, 400, fix="center")
names(temp.gr) <- temp.gr$Peak
temp.gr <- DistanceToTSS(temp.gr, TSS)
return(temp.gr)
}
ALL_merged_summits.gr <- loadSummits(file="ALL_merged_summits.bed")
addColumns <- function(anno.gr, table) {
## Add Columngs from GRanges to finalOutTable
names(anno.gr) <- gsub("All", "ALL", names(anno.gr))
remote.All  <- match(rownames(table), names(anno.gr))
table$Chrom <- as.character(seqnames(anno.gr)[remote.All])
table$Start <- start(anno.gr[remote.All])
table$End   <- end(anno.gr[remote.All])
table$Peak  <- anno.gr$Peak[remote.All]
table$Gene  <- anno.gr$Gene[remote.All]
table$DistanceToTSS  <- anno.gr$DistanceToTSS[remote.All]
return(table)
}
final.table.paxVall_All <- addColumns(ALL_merged_summits.gr, final.table)
# ### Save Table out
write.table(final.table.paxVall_All,
file="outs/DA_paxVall_ALL.txt",
sep="\t",
quote=F,
col.names=NA)
# view table
datatable(final.table.paxVall_All)
# source functions
source("~/Desktop/R_working/common_source_functions.R")
# setwd
setwd("~/Desktop/pax6 paper/Final Markdowns/ATAC/ATAC_DA/")
# setwd
setwd("~/Desktop/pax6 paper/Final Markdowns/ATAC/ATAC_DA/")
## Read in TSS for GO terms
paxVall <- read.table("outs/DA_paxVallP_ALL.txt", header = TRUE, sep = "\t", row.names = 1)
# read in DA tables
paxVall <- read.table("outs/DA_paxVallP_ALL.txt", header = TRUE, sep = "\t", row.names = 1) # paxVall aggregate
# setwd
setwd("~/Desktop/pax6 paper/Final Markdowns/ATAC/ATAC_DA/")
getwd()
# read in DA tables
paxVall <- read.table("outs/DA_paxVallP_ALL.txt", header = TRUE, sep = "\t", row.names = 1) # paxVall aggregate
